<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrandMeister - Last Heard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    
    <style>
        body {
            background-color: #f4f4f4;
            color: #333;
        }
        /* Estilos personalizados para os ícones de ordenação */
        th.sorted-asc::after {
            content: ' ▲';
        }
        th.sorted-desc::after {
            content: ' ▼';
        }
        /* CORREÇÃO PARA QUE O TEXTO DO CABEÇALHO QUEBRE AS LINHAS */
        thead th {
            white-space: normal;
        }
    </style>
</head>
<body>

    <div class="container my-4">
        <h1 class="text-center text-primary mb-4">BrandMeister - Last Heard</h1>
    
        <div class="filters text-center mb-4">
            <label for="callsign-filter" class="fw-bold me-2">Filtrar por Indicativo:</label>
            <select id="callsign-filter" class="form-select-sm d-inline-block w-auto me-3">
                <option value="">Todos</option>
            </select>
            
            <label for="tg-filter" class="fw-bold me-2">Filtrar por TG:</label>
            <select id="tg-filter" class="form-select-sm d-inline-block w-auto me-3">
                <option value="">Todos</option>
            </select>
            <button id="clear-filters" class="btn btn-secondary btn-sm">Limpar Filtros</button>
        </div>
    
        <div id="loading" class="text-center my-5 fs-5">
            A carregar dados...
        </div>
    
        <div class="table-responsive">
            <table id="heardTable" class="table table-striped table-hover table-sm" style="display: none;">
                <thead>
                    <tr>
                        <th data-column-index="2" data-type="date" class="bg-primary text-white fw-bold">Data</th>
                        <th data-column-index="4" data-type="string" class="bg-primary text-white fw-bold">Link Name</th>
                        <th data-column-index="6" data-type="number" class="bg-primary text-white fw-bold">Link ID</th>
                        <th data-column-index="7" data-type="number" class="bg-primary text-white fw-bold">Slot</th>
                        <th data-column-index="8" data-type="string" class="bg-primary text-white fw-bold">Call Type</th>
                        <th data-column-index="9" data-type="string" class="bg-primary text-white fw-bold">Source ID</th>
                        <th data-column-index="10" data-type="number" class="bg-primary text-white fw-bold">To TG</th>
                        <th data-column-index="13" data-type="string" class="bg-primary text-white fw-bold">State</th>
                        <th data-column-index="14" data-type="number" class="bg-primary text-white fw-bold">Duration</th>
                        <th data-column-index="15" data-type="number" class="bg-primary text-white fw-bold">RSSI</th>
                        <th data-column-index="17" data-type="number" class="bg-primary text-white fw-bold">Loss Rate</th>
                        <th data-column-index="20" data-type="string" class="bg-primary text-white fw-bold">Repeater Call</th>
                        <th data-column-index="21" data-type="string" class="bg-primary text-white fw-bold">Source Call</th>
                        <th data-column-index="22" data-type="string" class="bg-primary text-white fw-bold">Source Name</th>
                        <th data-column-index="23" data-type="string" class="bg-primary text-white fw-bold">Destination Call</th>
                        <th data-column-index="24" data-type="string" class="bg-primary text-white fw-bold">Destination Name</th>
                        <th data-column-index="25" data-type="string" class="bg-primary text-white fw-bold">Talker Alias</th>
                    </tr>
                </thead>
                <tbody>
                    </tbody>
            </table>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

    <script>
        const API_URL = 'https://bm-psi.vercel.app/api/last-heard';
        let allData = [];
        let currentSortColumn = null;
        let currentSortDirection = 'asc';

        // Mapeamento de números para estados de texto e classes Bootstrap
        const stateMap = {
            0: 'Idle',
            1: 'In Progress',
            2: 'Ended',
            3: 'Pre',
            4: 'Lost'
        };
        const stateClassMap = {
            'Idle': 'bg-warning text-dark',
            'In Progress': 'bg-success text-white',
            'Lost': 'bg-danger text-white',
            'Ended': 'bg-light text-dark'
        };

        // Mapeamento de números para tipos de chamada de texto
        const callTypeMap = {
            0: 'Private',
            1: 'Group',
            2: 'All',
            3: 'Data',
            4: 'Emergency',
            5: 'Unconfirmed Private',
            6: 'Unconfirmed Group',
            7: 'Group Voice'
        };

        const callsignFilter = document.getElementById('callsign-filter');
        const tgFilter = document.getElementById('tg-filter');
        const clearFiltersBtn = document.getElementById('clear-filters');
        const tableBody = document.querySelector('#heardTable tbody');
        const loadingMessage = document.getElementById('loading');
        const table = document.getElementById('heardTable');
        const tableHeaders = document.querySelectorAll('#heardTable thead th');

        function formatDuration(seconds) {
            // VERIFICA SE O VALOR É VÁLIDO ANTES DE FORMATAR
            if (typeof seconds !== 'number' || seconds < 0 || isNaN(seconds)) {
                return '';
            }
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(remainingSeconds).padStart(2, '0');
            return `${formattedMinutes}:${formattedSeconds}`;
        }

        // Determina a classe de cor do sinal com base no valor RSSI
        function getSignalClass(rssi) {
            if (rssi > -80) {
                return 'text-success'; // Sinal excelente (verde)
            } else if (rssi > -95) {
                return 'text-warning'; // Sinal bom/aceitável (amarelo)
            } else if (rssi > -110) {
                return 'text-danger'; // Sinal fraco (vermelho)
            }
            return 'text-secondary'; // Sinal muito fraco ou sem dados (cinzento)
        }

        // NOVA FUNÇÃO: Converte o valor de RSSI para a escala S-meter
        function getSunitFromRssi(rssi) {
            if (typeof rssi !== 'number') {
                return 'N/A';
            }

            if (rssi >= -73) {
                const s9Plus = Math.floor(rssi + 73);
                return `S9+${s9Plus}dB`;
            } else if (rssi >= -79) {
                return 'S9';
            } else if (rssi >= -85) {
                return 'S8';
            } else if (rssi >= -91) {
                return 'S7';
            } else if (rssi >= -97) {
                return 'S6';
            } else if (rssi >= -103) {
                return 'S5';
            } else if (rssi >= -109) {
                return 'S4';
            } else if (rssi >= -115) {
                return 'S3';
            } else if (rssi >= -121) {
                return 'S2';
            } else if (rssi >= -127) {
                return 'S1';
            } else {
                return 'S0';
            }
        }
        
        function renderTable(dataToRender) {
            tableBody.innerHTML = '';
            dataToRender.forEach(item => {
                const lossRateValue = (item[17] || item[17] === 0) ? `${item[17]}%` : '0%';
                const durationSeconds = item[14] * 0.06;
                const formattedDuration = formatDuration(durationSeconds);
                
                const stateValue = stateMap[item[13]] || '';
                const stateClass = stateClassMap[stateValue] || '';

                const callTypeValue = callTypeMap[item[8]] || 'N/A';

                const repeaterCallValue = item[20] || '';
                let repeaterClass = '';

                // Lógica de cores para o Repeater Call
                if (repeaterCallValue.toUpperCase().startsWith('CQO')) {
                    repeaterClass = 'text-success';
                } else if (repeaterCallValue.toUpperCase().startsWith('XLX') || repeaterCallValue.toUpperCase().startsWith('CS') || repeaterCallValue.toUpperCase().startsWith('REFLECTOR')) {
                    repeaterClass = 'text-primary';
                }
                
                // Obter a classe de cor para o RSSI
                const rssiValue = item[15] || '';
                const rssiClass = getSignalClass(rssiValue);
                const sunitValue = getSunitFromRssi(rssiValue);

                let rssiContent = '';
                if (typeof rssiValue === 'number') {
                    rssiContent = `<span class="${rssiClass}">${sunitValue}</span><br><span class="${rssiClass}">${rssiValue.toFixed(2)} dBm</span>`;
                } else {
                    rssiContent = `<span class="text-secondary">N/A</span>`;
                }

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${item[2] ? new Date(item[2] * 1000).toLocaleString() : ''}</td>
                    <td>${item[4] || ''}</td>
                    <td>${item[6] || ''}</td>
                    <td>${item[7] || ''}</td>
                    <td>${callTypeValue}</td>
                    <td>${item[9] || ''}</td>
                    <td>${item[10] || ''}</td>
                    <td><span class="badge ${stateClass}">${stateValue}</span></td>
                    <td>${formattedDuration}</td>
                    <td>${rssiContent}</td>
                    <td>${lossRateValue}</td>
                    <td><span class="${repeaterClass}">${repeaterCallValue}</span></td>
                    <td>${item[21] || ''}</td>
                    <td>${item[22] || ''}</td>
                    <td>${item[23] || ''}</td>
                    <td>${item[24] || ''}</td>
                    <td>${item[25] || ''}</td>
                `;
                tableBody.appendChild(row);
            });
            loadingMessage.style.display = 'none';
            table.style.display = 'table';
        }

        function populateFilters(data) {
            const callsigns = new Set();
            const tgs = new Set();
            
            data.forEach(item => {
                if (item[21]) callsigns.add(item[21]);
                if (item[10]) tgs.add(item[10]);
            });

            const sortedCallsigns = Array.from(callsigns).sort();
            callsignFilter.innerHTML = '<option value="">Todos</option>';
            sortedCallsigns.forEach(callsign => {
                const option = document.createElement('option');
                option.value = callsign;
                option.textContent = callsign;
                callsignFilter.appendChild(option);
            });

            const sortedTGs = Array.from(tgs).sort((a, b) => a - b);
            tgFilter.innerHTML = '<option value="">Todos</option>';
            sortedTGs.forEach(tg => {
                const option = document.createElement('option');
                option.value = tg;
                option.textContent = tg;
                tgFilter.appendChild(option);
            });

            // LÓGICA CORRIGIDA PARA O FILTRO: verifica se o valor guardado existe na nova lista
            const savedCallsign = localStorage.getItem('selectedCallsign');
            if (savedCallsign && sortedCallsigns.includes(savedCallsign)) {
                callsignFilter.value = savedCallsign;
            } else {
                callsignFilter.value = '';
                localStorage.removeItem('selectedCallsign');
            }

            const savedTg = localStorage.getItem('selectedTg');
            if (savedTg && sortedTGs.includes(parseInt(savedTg))) {
                tgFilter.value = savedTg;
            } else {
                tgFilter.value = '';
                localStorage.removeItem('selectedTg');
            }
        }

        function applyFiltersAndRender() {
            const selectedCallsign = callsignFilter.value;
            const selectedTg = tgFilter.value;
            
            let filteredData = allData;
            
            if (selectedCallsign) {
                filteredData = filteredData.filter(item => item[21] === selectedCallsign);
            }
            if (selectedTg) {
                filteredData = filteredData.filter(item => item[10] === parseInt(selectedTg));
            }
            
            if (currentSortColumn !== null) {
                const columnIndex = parseInt(currentSortColumn.dataset.columnIndex);
                const dataType = currentSortColumn.dataset.type;
                sortData(filteredData, columnIndex, dataType, currentSortDirection);
            }

            renderTable(filteredData);
        }

        function sortData(data, columnIndex, dataType, direction) {
            data.sort((a, b) => {
                let aValue = a[columnIndex];
                let bValue = b[columnIndex];
                
                if (dataType === 'number') {
                    aValue = parseFloat(aValue || 0);
                    bValue = parseFloat(bValue || 0);
                } else if (dataType === 'date') {
                    aValue = parseInt(aValue || 0);
                    bValue = parseInt(bValue || 0);
                } else {
                    aValue = String(aValue || '');
                    bValue = String(bValue || '');
                }

                if (aValue < bValue) {
                    return direction === 'asc' ? -1 : 1;
                }
                if (aValue > bValue) {
                    return direction === 'asc' ? 1 : -1;
                }
                return 0;
            });
        }

        callsignFilter.addEventListener('change', () => {
            localStorage.setItem('selectedCallsign', callsignFilter.value);
            applyFiltersAndRender();
        });
        tgFilter.addEventListener('change', () => {
            localStorage.setItem('selectedTg', tgFilter.value);
            applyFiltersAndRender();
        });
        
        clearFiltersBtn.addEventListener('click', () => {
            callsignFilter.value = '';
            tgFilter.value = '';
            localStorage.removeItem('selectedCallsign');
            localStorage.removeItem('selectedTg');
            applyFiltersAndRender();
        });

        tableHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const columnIndex = header.dataset.columnIndex;
                const dataType = header.dataset.type;
                
                if (currentSortColumn === header) {
                    currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    if (currentSortColumn) {
                        currentSortColumn.classList.remove('sorted-asc', 'sorted-desc');
                    }
                    currentSortColumn = header;
                    currentSortDirection = 'asc';
                }

                header.classList.remove('sorted-asc', 'sorted-desc');
                header.classList.add(`sorted-${currentSortDirection}`);
                
                applyFiltersAndRender();
            });
        });

        async function fetchData() {
            loadingMessage.style.display = 'block';
            table.style.display = 'none';

            try {
                const response = await fetch(API_URL);
                const data = await response.json();
                allData = data;
                
                populateFilters(allData);
                applyFiltersAndRender();

            } catch (error) {
                console.error('Erro ao obter dados:', error);
                loadingMessage.innerText = 'Erro ao carregar os dados. Tente novamente mais tarde.';
            }
        }

        fetchData();
        setInterval(fetchData, 30000);
    </script>
</body>
</html>